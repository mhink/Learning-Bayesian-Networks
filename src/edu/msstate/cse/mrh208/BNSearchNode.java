package edu.msstate.cse.mrh208;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

import edu.msstate.cse.mrh208.Bayes.BayesianNetwork;

//NOTE: The search graph is an order graph of variables.
public class BNSearchNode implements Comparable<BNSearchNode>{
	
	BNSearchNode parent;
	BayesianNetwork bayesianNetwork;
	int pathCost;
	int heuristicValue;
	List<BNSearchNode> successors;
	
	
	@Override
	public boolean equals(Object other) {
		//TODO: Figure out exactly how to compare BNSearchNodes. (Maybe based on underlying BN equality?)
		throw new UnsupportedOperationException();
	}
	
	@Override
	public int hashCode() {
		//TODO: Figure out a hashing function for BNSearchNodes. (Maybe based on underlying BN hashcodes?)
		throw new UnsupportedOperationException();
	}
	
	@Override
	public int compareTo(BNSearchNode arg0) {
		//TODO: Implement comparator for BNSearchNodes.  (Needs to be based off heuristic val. somehow, check old code for details)
		throw new UnsupportedOperationException();
	}
	
	public BNSearchNode(BNSearchNode parent, BayesianNetwork bayesianNetwork, int pathCost) {
		this.parent = parent;
		this.bayesianNetwork = bayesianNetwork;
		this.pathCost = pathCost;
		
		this.heuristicValue = calculateHeuristicValue();
	}
	
	public int estimatedTotalCost() {
		return this.pathCost + this.heuristicValue;
	}
	
	public boolean isGoal(BayesianNetwork goalNetwork) {
		return this.bayesianNetwork.hasSameVariables(goalNetwork);
	}
	
	private int calculateHeuristicValue() {
		//TODO: Implement heuristic calculation of BNs.
		throw new UnsupportedOperationException();
	}
	
	public void expand() {
		//TODO: Generate successor nodes.
		
		//NOTE: I'm pretty sure successor nodes are generated by selecting a variable, and finding the BestMDL
		//score against all combinations of parent variables (which, itself, is called the "parent graph".)
		//I don't think the parent graph is very big compared to the search graph, so this shouldn't introduce
		//TOO much complexity.
		throw new UnsupportedOperationException();
	}
	
	public List<BNSearchNode> getSuccessors() {
		return successors;
	}
	public int getPathCost() {
		return pathCost;
	}
	public static BNSearchNode bestPathCost(BNSearchNode bnsn1, BNSearchNode bnsn2) {
		if(bnsn1 == null && bnsn2 != null) return bnsn2;
		if(bnsn1 != null && bnsn2 == null) return bnsn1;
		
		if(bnsn1.pathCost < bnsn2.pathCost) return bnsn1;
		if(bnsn1.pathCost > bnsn2.pathCost) return bnsn2;
		if(bnsn1.pathCost == bnsn2.pathCost)return bnsn2;
		
		return null;
	}

}
